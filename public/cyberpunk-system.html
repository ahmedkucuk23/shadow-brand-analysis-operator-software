<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Cyberpunk Interactive System</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background: #000;
            font-family: 'Orbitron', monospace;
            touch-action: none;
        }
        
        /* Fullscreen camera background */
        #video-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            z-index: 0;
        }
        
        /* Dark overlay on camera */
        .camera-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.3);
            z-index: 1;
        }
        
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
        }
        
        /* Scanlines overlay */
        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 50;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15) 0px,
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 4px
            );
            opacity: 0.5;
        }
        
        /* Vignette */
        .vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 49;
            background: radial-gradient(ellipse at center, transparent 0%, transparent 40%, rgba(0,0,0,0.7) 100%);
        }
        
        /* HUD Elements */
        .hud {
            position: fixed;
            color: #00ffff;
            font-size: 10px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 1px;
            z-index: 100;
            text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 12px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
        }
        
        .hud-tl {
            top: 10px;
            left: 10px;
        }
        
        .hud-tr {
            top: 10px;
            right: 10px;
            text-align: right;
        }
        
        .hud-bl {
            bottom: 10px;
            left: 10px;
        }
        
        .hud-br {
            bottom: 10px;
            right: 10px;
            text-align: right;
        }
        
        .hud-value {
            font-size: 14px;
            font-weight: 700;
            color: #fff;
        }
        
        .hud-label {
            opacity: 0.7;
            font-size: 8px;
        }
        
        .status-active {
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88;
        }
        
        .status-inactive {
            color: #ff0066;
            text-shadow: 0 0 10px #ff0066;
        }
        
        /* Mode indicator */
        .mode-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            font-weight: 900;
            color: #00ffff;
            text-shadow: 0 0 30px #00ffff, 0 0 60px #00ffff;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            text-align: center;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 30px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }
        
        .mode-indicator.visible {
            opacity: 1;
        }
        
        /* Hand tracking point indicator */
        .hand-point {
            position: fixed;
            width: 30px;
            height: 30px;
            border: 3px solid #00ffff;
            border-radius: 50%;
            pointer-events: none;
            z-index: 80;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 20px #00ffff, inset 0 0 10px rgba(0, 255, 255, 0.3);
            display: none;
        }
        
        .hand-point.active {
            display: block;
        }
        
        .hand-point.left {
            border-color: #ff00ff;
            box-shadow: 0 0 20px #ff00ff, inset 0 0 10px rgba(255, 0, 255, 0.3);
        }
        
        .hand-point::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 8px;
            height: 8px;
            background: currentColor;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        
        /* Instructions overlay - hidden by default, only for standalone */
        .mobile-instructions {
            display: none;
        }
        
        /* Mobile responsive HUD */
        @media (max-width: 768px) {
            .hud {
                font-size: 8px;
                padding: 5px 8px;
            }
            
            .hud-value {
                font-size: 11px;
            }
            
            .hud-label {
                font-size: 6px;
            }
            
            .hud-bl, .hud-br {
                bottom: 5px;
            }
            
            .hud-tl, .hud-tr {
                top: 5px;
            }
            
            .mode-indicator {
                font-size: 14px;
                padding: 10px 20px;
            }
        }
        
        #text-canvas {
            display: none;
        }
        
        /* Loading screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #00ffff;
            text-align: center;
        }
        
        .loading-screen.hidden {
            display: none;
        }
        
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid #00ffff;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .loading-text {
            font-size: 14px;
            margin-bottom: 10px;
        }
        
        .loading-subtext {
            font-size: 10px;
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div class="loading-screen" id="loading-screen">
        <div class="loading-spinner"></div>
        <div class="loading-text">INITIALIZING SYSTEM</div>
        <div class="loading-subtext">Please allow camera access</div>
    </div>

    <!-- Fullscreen camera background -->
    <video id="video-bg" autoplay playsinline muted></video>
    <div class="camera-overlay"></div>
    
    <div class="vignette"></div>
    <div class="scanlines"></div>
    
    <div id="canvas-container"></div>
    
    <!-- Hand tracking indicators -->
    <div class="hand-point" id="right-hand-point"></div>
    <div class="hand-point left" id="left-hand-point"></div>
    
    <!-- HUD Elements -->
    <div class="hud hud-tl">
        <div class="hud-label">FPS</div>
        <div class="hud-value" id="fps">60</div>
    </div>
    
    <div class="hud hud-tr">
        <div class="hud-label">Particles</div>
        <div class="hud-value" id="particle-count">12000</div>
    </div>
    
    <div class="hud hud-bl">
        <div class="hud-label">Left Hand</div>
        <div class="hud-value" id="left-hand-status">--</div>
    </div>
    
    <div class="hud hud-br">
        <div class="hud-label">Right Hand</div>
        <div class="hud-value" id="right-hand-status">--</div>
    </div>
    
    <div class="mode-indicator" id="mode-indicator">INITIALIZING</div>
    
    
    <canvas id="text-canvas"></canvas>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        // ============================================
        // CONFIGURATION
        // ============================================
        const CONFIG = {
            particleCount: 12000,
            particleSize: 3.0,
            lerpFactor: 0.12,
            repulsionStrength: 100,
            repulsionRadius: 150,
            colors: {
                neonBlue: 0x00ffff,
                neonYellow: 0xffff00,
                neonPink: 0xff00ff,
                neonGreen: 0x00ff88,
                neonOrange: 0xff8800
            }
        };

        // ============================================
        // GLOBAL STATE
        // ============================================
        let scene, camera, renderer, particles;
        let particlePositions, particleTargets, particleColors, particleVelocities;
        let currentText = "Mita Agency";
        let currentColor = CONFIG.colors.neonBlue;
        let textCoords = [];
        let leftHandData = null;
        let rightHandData = null;
        let isNebulaMode = false;
        let isCatchMode = false;
        let isBasketballMode = false;
        let basketballAngle = 0;
        let frameCount = 0;
        let lastTime = performance.now();
        let fps = 60;

        // ============================================
        // TEXT GENERATION
        // ============================================
        function generateTextCoords(text) {
            const canvas = document.getElementById('text-canvas');
            const ctx = canvas.getContext('2d');
            
            // Adjust size based on screen
            const isMobile = window.innerWidth < 768;
            const fontSize = isMobile ? 45 : 75;
            
            canvas.width = isMobile ? 500 : 800;
            canvas.height = isMobile ? 200 : 300;
            
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.font = `bold ${fontSize}px Orbitron, sans-serif`;
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const coords = [];
            const step = isMobile ? 3 : 4;
            
            for (let y = 0; y < canvas.height; y += step) {
                for (let x = 0; x < canvas.width; x += step) {
                    const i = (y * canvas.width + x) * 4;
                    if (imageData.data[i] > 128) {
                        coords.push({
                            x: (x - canvas.width / 2) * (isMobile ? 0.6 : 0.8),
                            y: (canvas.height / 2 - y) * (isMobile ? 0.6 : 0.8),
                            z: 0
                        });
                    }
                }
            }
            
            return coords;
        }

        // ============================================
        // BASKETBALL SPHERE GENERATION (Fibonacci)
        // ============================================
        function generateBasketballCoords(radius = 80, count = 2000) {
            const coords = [];
            const goldenRatio = (1 + Math.sqrt(5)) / 2;
            
            for (let i = 0; i < count; i++) {
                const theta = 2 * Math.PI * i / goldenRatio;
                const phi = Math.acos(1 - 2 * (i + 0.5) / count);
                
                coords.push({
                    x: radius * Math.sin(phi) * Math.cos(theta),
                    y: radius * Math.sin(phi) * Math.sin(theta),
                    z: radius * Math.cos(phi),
                    theta: theta,
                    phi: phi
                });
            }
            
            return coords;
        }

        // ============================================
        // THREE.JS SETUP
        // ============================================
        function initThree() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.z = 400;
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(0x000000, 0); // Transparent background
            container.appendChild(renderer.domElement);
            
            // Create particles
            const geometry = new THREE.BufferGeometry();
            particlePositions = new Float32Array(CONFIG.particleCount * 3);
            particleTargets = new Float32Array(CONFIG.particleCount * 3);
            particleColors = new Float32Array(CONFIG.particleCount * 3);
            particleVelocities = new Float32Array(CONFIG.particleCount * 3);
            
            // Initialize particles randomly
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const i3 = i * 3;
                particlePositions[i3] = (Math.random() - 0.5) * 800;
                particlePositions[i3 + 1] = (Math.random() - 0.5) * 800;
                particlePositions[i3 + 2] = (Math.random() - 0.5) * 100;
                
                particleTargets[i3] = particlePositions[i3];
                particleTargets[i3 + 1] = particlePositions[i3 + 1];
                particleTargets[i3 + 2] = particlePositions[i3 + 2];
                
                particleVelocities[i3] = 0;
                particleVelocities[i3 + 1] = 0;
                particleVelocities[i3 + 2] = 0;
                
                const color = new THREE.Color(CONFIG.colors.neonBlue);
                particleColors[i3] = color.r;
                particleColors[i3 + 1] = color.g;
                particleColors[i3 + 2] = color.b;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));
            
            const material = new THREE.PointsMaterial({
                size: CONFIG.particleSize,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                transparent: true,
                opacity: 0.95,
                sizeAttenuation: true
            });
            
            particles = new THREE.Points(geometry, material);
            scene.add(particles);
            
            // Generate initial text
            textCoords = generateTextCoords(currentText);
            updateTargetsToText();
            
            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // Regenerate text coords for new size
            textCoords = generateTextCoords(currentText);
            if (!isNebulaMode && !isBasketballMode) {
                updateTargetsToText();
            }
        }

        // ============================================
        // TARGET UPDATES
        // ============================================
        function updateTargetsToText() {
            const coordCount = textCoords.length;
            
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const i3 = i * 3;
                if (coordCount > 0) {
                    const coord = textCoords[i % coordCount];
                    particleTargets[i3] = coord.x;
                    particleTargets[i3 + 1] = coord.y;
                    particleTargets[i3 + 2] = coord.z + (Math.random() - 0.5) * 5;
                }
            }
        }

        function updateTargetsToNebula() {
            const w = window.innerWidth * 0.4;
            const h = window.innerHeight * 0.4;
            
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const i3 = i * 3;
                particleTargets[i3] = (Math.random() - 0.5) * w;
                particleTargets[i3 + 1] = (Math.random() - 0.5) * h;
                particleTargets[i3 + 2] = (Math.random() - 0.5) * 300;
            }
        }

        function updateTargetsToBasketball(centerX, centerY) {
            const isMobile = window.innerWidth < 768;
            const radius = isMobile ? 60 : 80;
            const basketballCoords = generateBasketballCoords(radius, CONFIG.particleCount);
            
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const i3 = i * 3;
                const coord = basketballCoords[i % basketballCoords.length];
                
                const rotatedX = coord.x * Math.cos(basketballAngle) - coord.z * Math.sin(basketballAngle);
                const rotatedZ = coord.x * Math.sin(basketballAngle) + coord.z * Math.cos(basketballAngle);
                
                particleTargets[i3] = centerX + rotatedX;
                particleTargets[i3 + 1] = centerY + coord.y;
                particleTargets[i3 + 2] = rotatedZ;
                
                const isLine = Math.abs(Math.sin(coord.theta * 4)) < 0.1 || 
                               Math.abs(coord.phi - Math.PI/2) < 0.1;
                
                const color = isLine ? new THREE.Color(0x111111) : new THREE.Color(CONFIG.colors.neonOrange);
                particleColors[i3] = color.r;
                particleColors[i3 + 1] = color.g;
                particleColors[i3 + 2] = color.b;
            }
            
            particles.geometry.attributes.color.needsUpdate = true;
        }

        function updateParticleColors(targetColor) {
            const color = new THREE.Color(targetColor);
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const i3 = i * 3;
                particleColors[i3] = color.r;
                particleColors[i3 + 1] = color.g;
                particleColors[i3 + 2] = color.b;
            }
            particles.geometry.attributes.color.needsUpdate = true;
        }

        // ============================================
        // HAND TRACKING
        // ============================================
        function countExtendedFingers(landmarks) {
            const tips = [8, 12, 16, 20];
            const pips = [6, 10, 14, 18];
            let count = 0;
            
            const thumbTip = landmarks[4];
            const thumbIP = landmarks[3];
            const palmCenter = landmarks[0];
            const thumbDist = Math.hypot(thumbTip.x - palmCenter.x, thumbTip.y - palmCenter.y);
            const thumbIPDist = Math.hypot(thumbIP.x - palmCenter.x, thumbIP.y - palmCenter.y);
            if (thumbDist > thumbIPDist * 1.1) count++;
            
            for (let i = 0; i < tips.length; i++) {
                const tip = landmarks[tips[i]];
                const pip = landmarks[pips[i]];
                if (tip.y < pip.y) count++;
            }
            
            return count;
        }

        function getPalmCenter(landmarks) {
            const wrist = landmarks[0];
            const indexMCP = landmarks[5];
            const pinkyMCP = landmarks[17];
            
            return {
                x: (wrist.x + indexMCP.x + pinkyMCP.x) / 3,
                y: (wrist.y + indexMCP.y + pinkyMCP.y) / 3,
                z: (wrist.z + indexMCP.z + pinkyMCP.z) / 3
            };
        }

        function initMediaPipe() {
            const video = document.getElementById('video-bg');
            
            const hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });
            
            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.5
            });
            
            hands.onResults(onHandResults);
            
            const cam = new Camera(video, {
                onFrame: async () => {
                    await hands.send({ image: video });
                },
                width: 1280,
                height: 720,
                facingMode: 'user'
            });
            
            cam.start().then(() => {
                document.getElementById('loading-screen').classList.add('hidden');
                showModeIndicator('SYSTEM ONLINE');
            }).catch(err => {
                console.error('Camera error:', err);
                document.querySelector('.loading-text').textContent = 'CAMERA ACCESS REQUIRED';
                document.querySelector('.loading-subtext').textContent = 'Please refresh and allow camera';
            });
        }

        function onHandResults(results) {
            leftHandData = null;
            rightHandData = null;
            
            const rightPoint = document.getElementById('right-hand-point');
            const leftPoint = document.getElementById('left-hand-point');
            
            rightPoint.classList.remove('active');
            leftPoint.classList.remove('active');
            
            if (results.multiHandLandmarks && results.multiHandedness) {
                for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                    const landmarks = results.multiHandLandmarks[i];
                    const handedness = results.multiHandedness[i].label;
                    
                    if (handedness === 'Left') {
                        rightHandData = {
                            landmarks: landmarks,
                            fingerCount: countExtendedFingers(landmarks),
                            indexTip: landmarks[8],
                            palmCenter: getPalmCenter(landmarks)
                        };
                        
                        // Update visual indicator
                        rightPoint.classList.add('active');
                        rightPoint.style.left = (1 - rightHandData.indexTip.x) * window.innerWidth + 'px';
                        rightPoint.style.top = rightHandData.indexTip.y * window.innerHeight + 'px';
                    } else {
                        leftHandData = {
                            landmarks: landmarks,
                            fingerCount: countExtendedFingers(landmarks),
                            palmCenter: getPalmCenter(landmarks)
                        };
                        
                        // Update visual indicator
                        leftPoint.classList.add('active');
                        leftPoint.style.left = (1 - leftHandData.palmCenter.x) * window.innerWidth + 'px';
                        leftPoint.style.top = leftHandData.palmCenter.y * window.innerHeight + 'px';
                    }
                }
            }
            
            updateHandStates();
        }

        function showModeIndicator(text) {
            const modeIndicator = document.getElementById('mode-indicator');
            modeIndicator.textContent = text;
            modeIndicator.classList.add('visible');
            setTimeout(() => modeIndicator.classList.remove('visible'), 1200);
        }

        function updateHandStates() {
            const leftStatus = document.getElementById('left-hand-status');
            const rightStatus = document.getElementById('right-hand-status');
            
            // Left hand - shape control
            if (leftHandData) {
                const fingers = leftHandData.fingerCount;
                leftStatus.textContent = `${fingers} FINGERS`;
                leftStatus.className = 'hud-value status-active';
                
                isCatchMode = fingers >= 5;
                
                if (!isBasketballMode) {
                    let newText = currentText;
                    let newColor = currentColor;
                    
                    if (fingers === 1) {
                        newText = "Mita Agency";
                        newColor = CONFIG.colors.neonBlue;
                    } else if (fingers === 2) {
                        newText = "The best";
                        newColor = CONFIG.colors.neonYellow;
                    } else if (fingers === 3) {
                        newText = "Marketing";
                        newColor = CONFIG.colors.neonPink;
                    } else if (fingers === 4) {
                        newText = "Agency.";
                        newColor = CONFIG.colors.neonGreen;
                    }
                    
                    if (newText !== currentText && !isCatchMode) {
                        currentText = newText;
                        currentColor = newColor;
                        textCoords = generateTextCoords(currentText);
                        updateTargetsToText();
                        updateParticleColors(currentColor);
                        showModeIndicator(currentText);
                    }
                }
            } else {
                leftStatus.textContent = 'SEARCHING';
                leftStatus.className = 'hud-value status-inactive';
                isCatchMode = false;
            }
            
            // Right hand - physics interaction
            if (rightHandData) {
                const fingers = rightHandData.fingerCount;
                rightStatus.textContent = fingers >= 5 ? 'NEBULA' : 'SCATTER';
                rightStatus.className = 'hud-value status-active';
                
                const wasNebulaMode = isNebulaMode;
                isNebulaMode = fingers >= 5;
                
                if (isNebulaMode && !wasNebulaMode && !isBasketballMode) {
                    updateTargetsToNebula();
                    showModeIndicator('NEBULA MODE');
                } else if (!isNebulaMode && wasNebulaMode && !isBasketballMode) {
                    updateTargetsToText();
                }
            } else {
                rightStatus.textContent = 'SEARCHING';
                rightStatus.className = 'hud-value status-inactive';
                isNebulaMode = false;
            }
            
            // Basketball combo mode
            const wasBasketballMode = isBasketballMode;
            isBasketballMode = isNebulaMode && isCatchMode && leftHandData && rightHandData;
            
            if (isBasketballMode && !wasBasketballMode) {
                showModeIndicator('ðŸ€ BASKETBALL');
            } else if (!isBasketballMode && wasBasketballMode) {
                updateParticleColors(currentColor);
                if (isNebulaMode) {
                    updateTargetsToNebula();
                } else {
                    updateTargetsToText();
                }
            }
        }

        // ============================================
        // ANIMATION LOOP
        // ============================================
        function animate() {
            requestAnimationFrame(animate);
            
            // FPS calculation
            frameCount++;
            const currentTime = performance.now();
            if (currentTime - lastTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastTime = currentTime;
                document.getElementById('fps').textContent = fps;
            }
            
            const time = currentTime * 0.001;
            
            // Basketball mode
            if (isBasketballMode && leftHandData) {
                basketballAngle += 0.05;
                const palm = leftHandData.palmCenter;
                const centerX = (0.5 - palm.x) * window.innerWidth * 0.6;
                const centerY = (0.5 - palm.y) * window.innerHeight * 0.6;
                updateTargetsToBasketball(centerX, centerY);
            }
            
            // Update particle positions
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const i3 = i * 3;
                
                let targetX = particleTargets[i3];
                let targetY = particleTargets[i3 + 1];
                let targetZ = particleTargets[i3 + 2];
                
                // Basketball bouncing trajectory
                if (isBasketballMode) {
                    const dist = Math.hypot(
                        particlePositions[i3] - targetX,
                        particlePositions[i3 + 1] - targetY
                    );
                    if (dist > 15) {
                        const bounceOffset = Math.sin(time * 15 + i * 0.1) * 25 * (dist / 150);
                        targetY += bounceOffset;
                    }
                }
                
                // Right hand interaction
                if (rightHandData && !isBasketballMode) {
                    const indexTip = rightHandData.indexTip;
                    const handX = (0.5 - indexTip.x) * window.innerWidth * 0.6;
                    const handY = (0.5 - indexTip.y) * window.innerHeight * 0.6;
                    
                    const dx = particlePositions[i3] - handX;
                    const dy = particlePositions[i3 + 1] - handY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < CONFIG.repulsionRadius) {
                        const force = (1 - dist / CONFIG.repulsionRadius) * CONFIG.repulsionStrength;
                        
                        if (isNebulaMode) {
                            const ripple = Math.sin(dist * 0.1 - time * 5) * 15;
                            particleVelocities[i3] += (dx / dist) * force * 0.4;
                            particleVelocities[i3 + 1] += (dy / dist) * force * 0.4;
                            particleVelocities[i3 + 2] += ripple * 0.08;
                        } else {
                            particleVelocities[i3] += (dx / dist) * force;
                            particleVelocities[i3 + 1] += (dy / dist) * force;
                        }
                    }
                }
                
                // Apply velocity
                particlePositions[i3] += particleVelocities[i3];
                particlePositions[i3 + 1] += particleVelocities[i3 + 1];
                particlePositions[i3 + 2] += particleVelocities[i3 + 2];
                
                // Dampen velocity
                particleVelocities[i3] *= 0.88;
                particleVelocities[i3 + 1] *= 0.88;
                particleVelocities[i3 + 2] *= 0.88;
                
                // Lerp towards target
                particlePositions[i3] += (targetX - particlePositions[i3]) * CONFIG.lerpFactor;
                particlePositions[i3 + 1] += (targetY - particlePositions[i3 + 1]) * CONFIG.lerpFactor;
                particlePositions[i3 + 2] += (targetZ - particlePositions[i3 + 2]) * CONFIG.lerpFactor;
            }
            
            particles.geometry.attributes.position.needsUpdate = true;
            
            renderer.render(scene, camera);
        }

        // ============================================
        // INITIALIZATION
        // ============================================
        function init() {
            initThree();
            initMediaPipe();
            animate();
        }

        window.addEventListener('load', init);
    </script>
</body>
</html>
